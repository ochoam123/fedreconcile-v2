import { NextResponse } from 'next/server';
import path from 'path';
import * as fsPromises from 'fs/promises'; // For promise-based async file operations
import * as fsSync from 'fs'; // For synchronous operations like existsSync
import os from 'os';

export async function POST(request: Request) {
  // We will still temporarily save files because the Cloud Function expects them as base64 in a JSON body.
  const tempDir = os.tmpdir();
  let gtasTempInputPath: string | undefined;
  let erpTempInputPath: string | undefined;

  try {
    const formData = await request.formData();
    const gtasFile = formData.get('gtas') as File | null;
    const erpFile = formData.get('erp') as File | null;

    if (!gtasFile || !erpFile) {
      return NextResponse.json({ success: false, message: 'Both GTAS and ERP files are required.' }, { status: 400 });
    }

    // Convert files to ArrayBuffer, then to Buffer, then to Base64 for sending to Cloud Function
    const gtasBuffer = Buffer.from(await gtasFile.arrayBuffer());
    const erpBuffer = Buffer.from(await erpFile.arrayBuffer());

    const gtasFileB64 = gtasBuffer.toString('base64');
    const erpFileB64 = erpBuffer.toString('base64');

    // For debugging, optionally save input files to temp locally, though not strictly needed for the fetch
    // These will be cleaned up in the finally block.
    gtasTempInputPath = path.join(tempDir, gtasFile.name);
    erpTempInputPath = path.join(tempDir, erpFile.name);
    await fsPromises.writeFile(gtasTempInputPath, gtasBuffer);
    await fsPromises.writeFile(erpTempInputPath, erpBuffer);
    console.log(`Input files temporarily saved for local review: ${gtasTempInputPath}, ${erpTempInputPath}`);


    // --- Make HTTP POST call to your Deployed Google Cloud Function ---
    // IMPORTANT: Make sure this URL matches the exact URL of YOUR DEPLOYED GOOGLE CLOUD FUNCTION!
    // You copied this URL after successful gcloud functions deploy.
    const cloudFunctionUrl = 'https://us-central1-fedreconcile-prototype.cloudfunctions.net/gtas-validator-http'; // <--- CONFIRM/REPLACE THIS URL!

    const pythonApiPayload = {
      gtas_file_b64: gtasFileB64,
      erp_file_b64: erpFileB64
    };

    const cloudFnResponse = await fetch(cloudFunctionUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(pythonApiPayload),
    });

    if (!cloudFnResponse.ok) {
      const errorText = await cloudFnResponse.text();
      console.error('Cloud Function Error Response:', errorText);
      throw new Error(`Cloud Function responded with an error: ${cloudFnResponse.status} - ${errorText}`);
    }

    const cloudFnData = await cloudFnResponse.json();
    console.log('Cloud Function Response Data:', cloudFnData);

    // Decode base64 reports received from Cloud Function and save them locally for download
    const exceptionReportB64 = cloudFnData.exception_report_b64;
    const fbdiJournalB64 = cloudFnData.fbdi_journal_b64;
    const exceptionReportFilename = cloudFnData.exception_report_filename || 'exception_report.xlsx';
    const fbdiJournalFilename = cloudFnData.fbdi_journal_filename || 'fbdi_journal_corrections.csv';

    // Paths where the generated reports will be temporarily stored on the Node.js server side for download by frontend
    const exceptionReportLocalPath = path.join(tempDir, exceptionReportFilename);
    const fbdiJournalLocalPath = path.join(tempDir, fbdiJournalFilename);

    if (exceptionReportB64) {
      await fsPromises.writeFile(exceptionReportLocalPath, Buffer.from(exceptionReportB64, 'base64'));
    }
    if (fbdiJournalB64) {
      await fsPromises.writeFile(fbdiJournalLocalPath, Buffer.from(fbdiJournalB64, 'base64'));
    }

    return NextResponse.json({
      success: true,
      message: cloudFnData.message || 'Validation complete. Reports generated by Cloud Function.',
      exceptionReportUrl: `/gtas-validator/download/${encodeURIComponent(exceptionReportFilename)}`,
      fbdiJournalUrl: `/gtas-validator/download/${encodeURIComponent(fbdiJournalFilename)}`,
    });

  } catch (error: any) {
    console.error('Error calling Cloud Function:', error);
    // Attempt to clean up temp input files (if they were saved) on error
    if (gtasTempInputPath && fsSync.existsSync(gtasTempInputPath)) {
        await fsPromises.unlink(gtasTempInputPath).catch(() => {});
    }
    if (erpTempInputPath && fsSync.existsSync(erpTempInputPath)) {
        await fsPromises.unlink(erpTempInputPath).catch(() => {});
    }

    return NextResponse.json({ success: false, message: error.message || 'Internal server error calling Cloud Function.' }, { status: 500 });
  } finally {
    // Ensure temporary input files are cleaned up if they were saved, regardless of success or failure
    if (gtasTempInputPath && fsSync.existsSync(gtasTempInputPath)) {
        await fsPromises.unlink(gtasTempInputPath).catch(() => {});
    }
    if (erpTempInputPath && fsSync.existsSync(erpTempInputPath)) {
        await fsPromises.unlink(erpTempInputPath).catch(() => {});
    }
  }
}